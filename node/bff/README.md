## Backends For Frontends(BFF)

### BFFの便利なユースケース

- API Gateway
- Server Side Rendering
- Session Management
- File Upload
- WebSocket、Server Sent Events、Long Polling


![BFF-Usecase](http://image.itmedia.co.jp/ait/articles/1803/12/news012_09.jpg)

- [BFF（Backends For Frontends）の5つの便利なユースケース](http://www.atmarkit.co.jp/ait/articles/1805/18/news022.html)


### BFFのアンチパターン

#### スパースコミニケーション
コミニケーションを不足させてしまう

- アーキテクチャを疎結合（スパース）にした結果、コミニケーションも疎にしてしまう
- 原因は、「報告、連絡、相談」を軽視してしまいがち
- BFFでアーキテクチャを粗結合にしたとしても、フロントエンドとバックエンドエンジニアとのコミニケーションを疎かにしていいことにはならない

=>解決策
- 「コミニケーション」を取る以外に無い。APIの認識齟齬は減らせる
- 「Swagger」、「Agreed」などのAPI仕様を一緒に同じリポジトリで管理

「Consumer Driven Contract」という方法もある。
- APIの仕様をフロントエンドが主導して決める
- フロントエンドが投げたいHTTP RequestとResponseの定義を記述する。これを「Contact(契約)」と呼ぶ。
- このContactを元にAPIのモックサーバーを作る

#### ファットフロント
BFFに処理を寄せすぎてしまう

- BFFを立てることで、様々な処理をBFFに移譲させられ、バックエンドでセッションを管理する必用はなくなる
- BFFはあくまでもフロントエンドでWEBページやユーザーインターフェース(UI)を作るためのサーバ

- バックエンドから処理を移譲させすぎると、BFFの負荷が高まって、サービス全体の性能が下がる可能性がある

##### example
「N+1問題」がBFFで発生してしまった。
- 1. 検索などの一覧処理を行うAPIをシンプルにしたかった。
- 2. 一覧の取得に、一度の処理で表示に必要な情報を取得させず、「一覧処理(idのみをリストに格納して返す処理)」、「詳細情報の取得処理(idから属性を取得させる)」に分けてしまった。
- 3. 2のような用に分けてしまったため、複数回のリクエストを発行しなくてはいけなくなった

- 最初から一覧取得時には、一覧情報の中に詳細情報が含まれている方が望ましい。
- 1回のリクエストで必要な情報が取得できて、BFFに負荷が高まらない

=>解決策
- BFFとバックエンドの責務を明確にする
- BFFはUIのためのサーバーであり、表示に関わる処理が主な役割
- BFFに「ビジネスロジック」や「ドメインロジック」を実装してはいけない。バックエンドの役割


#### ビックバンジョイン
最後に一気に結合させる

- いきなり全てのバックエンドとBFFを結合させてはいけない
- 定期的なタイミングで少しずつバックエンドと結合させる
- 未実装のAPIはMockを利用する
- 徐々に実装済みのバックエンドと結合する
